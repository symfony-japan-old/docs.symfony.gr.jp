
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>HTTP キャッシュ | Symfony2日本語ドキュメント</title>
    <link rel="stylesheet" href="../static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../static/configurationblock.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
      <script type="text/javascript" src="../static/js/jquery.corner.js"></script>
      <script type="text/javascript" src="../static/configurationblock.js"></script>
      <script type="text/javascript">
      $(function(){
          $('.section h1').corner();
          $('.highlight-python pre').corner();
          $('.highlight-yml pre').corner();
          $('.highlight').corner();
      });
      </script>
    <link rel="top" title="Symfony2Doc 1.0.0 documentation" href="../index.html" />
    <link rel="up" title="ガイドブック" href="index.html" />
    <link rel="next" title="翻訳" href="translation.html" />
    <link rel="prev" title="セキュリティ" href="security.html" /> 
  </head>
  <body>
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ja_JP/all.js#xfbml=1&appId=47270766548";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<div id="all">
  <div id="content">
    <div id="content_wrapper">
      <div id="top_menu">
        <div id="top_menu_wrapper">
        </div>
      </div>
      <div id="header_top">
        <h1 id="logo_top"><a href="http://docs.symfony.gr.jp/">Symfonyユーザー会ドキュメントポータル</a></h1>
        <div id="header_top_left"></div>
      </div>
      <!-- end #header -->
      <div id="navbar">
        <ul>
          <li><a href="../index.html">トップ（索引）</a></li>
          <li><a href="../quick_tour/index.html">クイックツアー</a></li>
          <li><a href="index.html">ガイドブック</a></li>
          <li><a href="../cookbook/index.html">クックブック</a></li>
          <li><a href="../components/index.html">コンポーネント</a></li>
          <li><a href="../reference/index.html">リファレンス</a></li>
          <li><a href="../contributing/index.html">貢献</a></li>
        </ul>
      </div>
      <!-- end #navbar -->
      <div id="main">  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3>このページのコンテンツ</h3>
  <ul>
<li><a class="reference internal" href="#">HTTP キャッシュ</a><ul>
<li><a class="reference internal" href="#id1">巨人の肩に乗ってキャッシュする</a></li>
<li><a class="reference internal" href="#gateway-caches">ゲートウェイキャッシュを使ったキャッシュ</a><ul>
<li><a class="reference internal" href="#index-2">キャッシュの種類</a></li>
<li><a class="reference internal" href="#symfony2">Symfony2 リバースプロキシ</a></li>
</ul>
</li>
<li><a class="reference internal" href="#http-cache-introduction">HTTP キャッシュの導入</a><ul>
<li><a class="reference internal" href="#cache-control">Cache-Control ヘッダー</a></li>
<li><a class="reference internal" href="#public-private">レスポンスの Public と Private</a></li>
<li><a class="reference internal" href="#index-6">安全なメソッド</a></li>
<li><a class="reference internal" href="#id6">キャッシュのルールとデフォルト</a></li>
</ul>
</li>
<li><a class="reference internal" href="#http-expiration-validation">HTTP キャッシュの有効期限と期限切れの検証</a><ul>
<li><a class="reference internal" href="#index-7">有効期限</a></li>
<li><a class="reference internal" href="#expires"><tt class="docutils literal"><span class="pre">Expires</span></tt> ヘッダーを使った有効期限の設定</a></li>
<li><a class="reference internal" href="#index-9"><tt class="docutils literal"><span class="pre">Cache-Control</span></tt> ヘッダーを使った有効期限の設定</a></li>
<li><a class="reference internal" href="#index-10">期限切れの検証</a></li>
<li><a class="reference internal" href="#etag"><tt class="docutils literal"><span class="pre">ETag</span></tt> ヘッダーを使った検証</a></li>
<li><a class="reference internal" href="#last-modified"><tt class="docutils literal"><span class="pre">Last-Modified</span></tt> ヘッダーを使った検証</a></li>
<li><a class="reference internal" href="#optimizing-cache-validation">有効期限の検証を使ってコードを最適化する</a></li>
<li><a class="reference internal" href="#varying-the-response">Varying the Response</a></li>
<li><a class="reference internal" href="#id16">有効期限と期限の検証</a></li>
<li><a class="reference internal" href="#response">Response の他のメソッド</a></li>
</ul>
</li>
<li><a class="reference internal" href="#edge-side-includes">Edge Side Includes の使い方</a><ul>
<li><a class="reference internal" href="#using-esi-in-symfony2">Using ESI in Symfony2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cache-invalidation">Cache Invalidation</a></li>
<li><a class="reference internal" href="#summary">Summary</a></li>
<li><a class="reference internal" href="#learn-more-from-the-cookbook">Learn more from the Cookbook</a></li>
</ul>
</li>
</ul>

  <h4>前のドキュメント</h4>
  <p class="topless"><a href="security.html"
                        title="previous chapter">セキュリティ</a></p>
  <h4>次のドキュメント</h4>
  <p class="topless"><a href="translation.html"
                        title="next chapter">翻訳</a></p>
  <h3>ソース</h3>
  <ul class="this-page-menu">
    <li><a href="../sources/book/http_cache.txt"
           rel="nofollow">ページのソースを表示</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>クイック検索</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
          <br />
          <br />
          <div id="other">
            <h3>クイックリンク</h3>
            <ul>
              <li><a href="installation.html">インストール方法</a></li>
              <li><a href="../reference/forms/types.html">FormTypeリファレンス</a></li>
              <li><a href="../reference/constraints.html">バリデータリファレンス</a></li>
              <li><a href="http://twig.sensiolabs.org/documentation">Twigリファレンス</a></li>
              <li><a href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/annotations-reference.html">Doctrine ORMアノテーションリファレンス</a></li>
            </ul>

<br />
            <h3>コメントリスト</h3>

<script type="text/javascript" src="http://symfony-japan.disqus.com/combination_widget.js?num_items=10&hide_mods=0&color=grey&default_tab=recent&excerpt_length=200"></script><a href="http://disqus.com/">Powered by Disqus</a>


            <br />
            <p>ご質問や翻訳不備等お気軽にコメントください。</p>

            <br />
          </div>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="http">
<span id="index-0"></span><h1>HTTP キャッシュ<a class="headerlink" href="#http" title="Permalink to this headline">¶</a></h1>
<p>リッチな Web アプリケーションの本質は、それが動的であるということでしょう。
アプリケーションがどんなに効率的であったとしても、静的なファイルと比較して動的なファイルへのリクエストは必ずオーバーヘッドが発生します。</p>
<p>多くの Web アプリケーションのケースでは、Symfony2 はとても高速に動作するので、苦労してチューニングしなくても、サーバーに負荷をかけることなく、素早くレスポンスが返されます。</p>
<p>しかし、サイトへのアクセスが多くなると、小さなオーバーヘッドでも現実問題となってくるケースもあります。
このような場合は、それまでリクエストのたびに実行していた処理を、1 回だけ実行されるようにします。
これがキャッシュの目的です。</p>
<div class="section" id="id1">
<h2>巨人の肩に乗ってキャッシュする<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>アプリケーションのパフォーマンスを向上させる最も効果的な方法は、ページ全体の出力をキャッシュし、それ以降のリクエストに対してはアプリケーションの処理が実行されないようにすることです。
もちろん、動的な部分の多いサイトでは、この方法が使えない場合もあります。そういった場合に使える方法はないのでしょうか。
この章では、Symfony2 のキャッシュシステムの機能を説明します。
この章を読むと、Symfony2 のキャッシュのアプローチがとても優れていることが分かるでしょう。</p>
<p>Symfony2 のキャッシュシステムは、これまで他の似たようなフレームワークで実装されていたキャッシュシステムとは一線を画しています。
なぜなら、Symfony2 のキャッシュシステムは、<a class="reference internal" href="../glossary.html#term-http"><em class="xref std std-term">HTTP 仕様</em></a> に定義されているとてもシンプルで強力な HTTP キャッシュを実装したものだからです。
キャッシュの手法を再発明するのではなく、Web 上の基本的なプロトコルを定義している標準に準拠することにしたのです。
ですので、HTTP キャッシュの有効期限や検証のモデルについて、基本を一度理解すれば、Symfony2 のキャッシュシステムも理解できます。</p>
<p>Symfony2 のキャッシュを学ぶにあたり、次の 4 つのステップで順に説明していきます。</p>
<ul class="simple">
<li><strong>ステップ 1</strong>: <a class="reference internal" href="#gateway-caches"><em>ゲートウェイキャッシュ</em></a> またはリバースプロキシと呼ぶ、アプリケーションの手前に位置する独立したレイヤーについて解説します。
リバースプロキシでは、アプリケーションから返されたレスポンスをそのままキャッシュし、アプリケーションに対してリクエストがあると、代わりにキャッシュされたレスポンスを返します。
Symfony2 には独自のリバースプロキシが実装されていますが、他のリバースプロキシを利用することもできます。</li>
<li><strong>ステップ 2</strong>: <a class="reference internal" href="#http-cache-introduction"><em>HTTP キャッシュ</em></a> ヘッダーを使うと、アプリケーションとクライアントの間にある、ゲートウェイキャッシュ等のキャッシュシステムと情報をやりとりできます。
Symfony2 には、キャッシュヘッダーに関する使いやすいデフォルトの設定と、キャッシュヘッダーを操作するための強力なインタフェースがあります。</li>
<li><strong>ステップ 3</strong>: HTTP <a class="reference internal" href="#http-expiration-validation"><em>有効期限と検証</em></a>
は、キャッシュされたコンテンツが <em>最新</em>
(キャッシュから利用可能) か <em>古い</em> (アプリケーションから再生性する必要がある) かを決定するために使う 2 つのモデルです。</li>
<li><strong>ステップ 4</strong>: <a class="reference internal" href="#edge-side-includes"><em>Edge Side Includes</em></a> (ESI) を使うと、HTTP キャッシュシステムでページの断片を個別にキャッシュできるようになります。ネストされたページ断片も扱えます。
ESI では、ページ全体は 60 分キャッシュし、そこに埋め込まれたサイドバーは 5 分のみキャッシュするということが可能になります。</li>
</ul>
<p>HTTP キャッシュは Symfony に限った技術ではありませんので、さまざまな解説記事がすでにあります。
HTTP キャッシュについて初めて学ぶ方は、Ryan Tomayko 氏の記事 <a class="reference external" href="http://tomayko.com/writings/things-caches-do">Things Caches Do</a> を一読しておくことをおすすめします。
さらに詳細な解説は、Mark Nottingham 氏の <a class="reference external" href="http://www.mnot.net/cache_docs/">Cache Tutorial</a> です。</p>
</div>
<div class="section" id="gateway-caches">
<span id="index-1"></span><span id="id2"></span><h2>ゲートウェイキャッシュを使ったキャッシュ<a class="headerlink" href="#gateway-caches" title="Permalink to this headline">¶</a></h2>
<p>HTTP でキャッシュを行う場合、<em>キャッシュ</em>はアプリケーションから完全に分離され、アプリケーションとリクエストを送信するクライアントとの間で動作します。</p>
<p>キャッシュの仕事は、クライアントからのリクエストを受け取り、それをアプリケーションへ引き渡すことです。
同様に、アプリケーションからのレスポンスを受け取って、クライアントへ返します。
つまり、キャッシュはクライアントとアプリケーションとの間でリクエストとレスポンスの通信を仲介します。</p>
<p>クライアントとアプリケーションの間で仲介をしながら、&#8221;キャッシュ可能&#8221; とみなせるレスポンス（<a class="reference internal" href="#http-cache-introduction"><em>HTTP キャッシュの導入</em></a>）をキャッシュに保存します。
同じリソースが再度リクエストされた場合、キャッシュされたレスポンスがクライアントへ返され、アプリケーションは実行されません。</p>
<p>このように動作するキャッシュは、HTTP ゲートウェイキャッシュと呼ばれ、<a class="reference external" href="http://www.varnish-cache.org/">Varnish</a>、<a class="reference external" href="http://wiki.squid-cache.org/SquidFaq/ReverseProxy">リバースプロキシモードの Squid</a>等、すでに多くのものが存在します。
Symfony2 リバースプロキシもこの 1 つです。</p>
<div class="section" id="index-2">
<span id="id3"></span><h3>キャッシュの種類<a class="headerlink" href="#index-2" title="Permalink to this headline">¶</a></h3>
<p>ゲートウェイキャッシュがキャッシュの唯一の方法というわけではありません。
実際、アプリケーションから送信される HTTP キャッシュヘッダーは、次の 3 種類のキャッシュシステムで受け取って処理されます。</p>
<ul class="simple">
<li><em>ブラウザのキャッシュ</em>: すべてのブラウザには、ローカルキャッシュ機能が実装されています。
&#8220;戻る&#8221; ボタンを押したときや、画像などのアセットが何度も表示される場合にローカルキャッシュが使われます。
ブラウザキャッシュは<em>プライベート</em>キャッシュなので、キャッシュされたリソースが他人と共有されることはありません。</li>
<li><em>プロキシキャッシュ</em>: プロキシは<em>共有</em>キャッシュで、多くのユーザーに代わって 1 人のユーザーがアクセスします。
通常は、大企業や ISP でレイテンシやネットワークのトラフィックを低下させる目的でインストールされます。</li>
<li><em>ゲートウェイキャッシュ</em>: プロキシと似ていますが、サーバーサイドで、キャッシュを<em>共有</em>します。
インストールはネットワーク管理者が行い、Web サイトの可用性、信頼性、パフォーマンスを向上させます。</li>
</ul>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">ゲートウェイキャッシュは、リバースプロキシキャッシュ、サロゲートキャッシュ、HTTP アクセラレータと呼ばれることもあります。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">キャッシュが <em>プライベート</em> であるか <em>共有</em> であるかは、たとえばアカウント情報画面のように厳密に 1 人のユーザーにのみ固有なコンテンツを含むレスポンスをキャッシュする場合に重要になります。</p>
</div>
<p>アプリケーションのレスポンスには、最初の 2 つのうちのどちらか一方、または両方を利用できることが多いでしょう。
これらのキャッシュを利用する場合、キャッシュデータを直接管理することはできませんので、レスポンスで HTTP キャシュの命令セットを使うことになります。</p>
</div>
<div class="section" id="symfony2">
<span id="symfony-gateway-cache"></span><span id="index-3"></span><h3>Symfony2 リバースプロキシ<a class="headerlink" href="#symfony2" title="Permalink to this headline">¶</a></h3>
<p>Symfony2 には、PHP で記述されたリバースプロキシ（またはゲートウェイキャッシュと呼ばれる）が組み込まれています。
リバースプロキシを有効にすると、アプリケーションからキャッシュ可能なレスポンスが返された場合、すぐにキャッシュされます。
リバースプロキシのインストールはとても簡単です。
Symfony2 アプリケーションには、あらかじめキャッシュカーネル (<tt class="docutils literal"><span class="pre">AppCache</span></tt>) の設定がされています。
キャッシュカーネルは、デフォルトのカーネル (<tt class="docutils literal"><span class="pre">AppKernel</span></tt>) をラップします。
このキャッシュカーネルが、リバースプロキシとして機能します。</p>
<p>キャッシュを有効にするには、キャッシュカーネルを使うようにフロントコントローラのコードを次のように変更します。</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// web/app.php</span>

<span class="k">require_once</span> <span class="nx">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../app/bootstrap.php.cache&#39;</span><span class="p">;</span>
<span class="k">require_once</span> <span class="nx">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../app/AppKernel.php&#39;</span><span class="p">;</span>
<span class="k">require_once</span> <span class="nx">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../app/AppCache.php&#39;</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Symfony\Component\HttpFoundation\Request</span><span class="p">;</span>

<span class="nv">$kernel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AppKernel</span><span class="p">(</span><span class="s1">&#39;prod&#39;</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
<span class="nv">$kernel</span><span class="o">-&gt;</span><span class="na">loadClassCache</span><span class="p">();</span>
<span class="c1">// デフォルトの AppKernel を AppCache でラップ</span>
<span class="nv">$kernel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AppCache</span><span class="p">(</span><span class="nv">$kernel</span><span class="p">);</span>
<span class="nv">$kernel</span><span class="o">-&gt;</span><span class="na">handle</span><span class="p">(</span><span class="nx">Request</span><span class="o">::</span><span class="na">createFromGlobals</span><span class="p">())</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>
</pre></div>
</div>
<p>これですぐに、キャッシュカーネルがリバースプロキシとして動作し始めます。
つまり、アプリケーションからのレスポンスをキャッシュし、クライアントにキャッシュを返します。</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>キャッシュカーネルには、キャッシュレイヤーでの処理内容を文字列で返す <tt class="docutils literal"><span class="pre">getLog()</span></tt> メソッドがあります。
開発環境では、このメソッドを使ってキャッシュ戦略を検証できます。</p>
<div class="last highlight-php"><div class="highlight"><pre><span class="nb">error_log</span><span class="p">(</span><span class="nv">$kernel</span><span class="o">-&gt;</span><span class="na">getLog</span><span class="p">());</span>
</pre></div>
</div>
</div>
<p><tt class="docutils literal"><span class="pre">AppCache</span></tt> オブジェクトのデフォルトコンフィギュレーションは、十分に実用的ですが、開発するアプリケーションに合わせて細かく調整したい場合は <tt class="docutils literal"><span class="pre">getOptions()</span></tt> メソッドをオーバーライドして、キャッシュ用の一連のオプションを書き換えることができます。</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// app/AppCache.php</span>
<span class="k">class</span> <span class="nc">AppCache</span> <span class="k">extends</span> <span class="nx">Cache</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">getOptions</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;debug&#39;</span>                  <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
            <span class="s1">&#39;default_ttl&#39;</span>            <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;private_headers&#39;</span>        <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;Authorization&#39;</span><span class="p">,</span> <span class="s1">&#39;Cookie&#39;</span><span class="p">),</span>
            <span class="s1">&#39;allow_reload&#39;</span>           <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
            <span class="s1">&#39;allow_revalidate&#39;</span>       <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
            <span class="s1">&#39;stale_while_revalidate&#39;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
            <span class="s1">&#39;stale_if_error&#39;</span>         <span class="o">=&gt;</span> <span class="mi">60</span><span class="p">,</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><tt class="docutils literal"><span class="pre">debug</span></tt> の値は、<tt class="docutils literal"><span class="pre">getOptions()</span></tt>メソッドで指定しない場合、<tt class="docutils literal"><span class="pre">AppKernel</span></tt>で設定された値に自動的に設定されます。</p>
</div>
<p>主要なオプションの一覧は以下のとおりです:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">default_ttl</span></tt>: レスポンスで明示的に最新かどうかを判定する情報が指定されなかった場合に、キャッシュエントリが最新であると判定される秒数。
明示的に <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> または <tt class="docutils literal"><span class="pre">Expires</span></tt> ヘッダーを指定した場合、この値は上書きされます (デフォルト: <tt class="docutils literal"><span class="pre">0</span></tt>);</li>
<li><tt class="docutils literal"><span class="pre">private_headers</span></tt>: レスポンスの <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> ディレクティブによって <tt class="docutils literal"><span class="pre">public</span></tt> ステートまたは <tt class="docutils literal"><span class="pre">private</span></tt> ステートが明示的に指定されていない場合でも、自動的に <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> を &#8220;private&#8221; として扱う他のヘッダー (デフォルト: <tt class="docutils literal"><span class="pre">Authorization</span></tt> と <tt class="docutils literal"><span class="pre">Cookie</span></tt>)。</li>
<li><tt class="docutils literal"><span class="pre">allow_reload</span></tt>: クライアントからリクエストに <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> &#8220;no-cache&#8221; ディレクティブを指定して、キャッシュを強制的にリロード可能かどうか。
RFC 2616 に従うには <tt class="docutils literal"><span class="pre">true</span></tt> に設定してください (デフォルト: <tt class="docutils literal"><span class="pre">false</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">allow_revalidate</span></tt>: クライアントからリクエストに <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> &#8220;max-age=0&#8221; ディレクティブを指定して、キャッシュの有効期限を強制的に再検証させることが可能かどうか。
RFC 2616 に従うには <tt class="docutils literal"><span class="pre">true</span></tt> に設定してください (デフォルト: <tt class="docutils literal"><span class="pre">false</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">stale_while_revalidate</span></tt>: キャッシュが有効期限切れになりバックグラウンドで再検証が実行されている間、&#8221;stale&#8221; レスポンスを即座に返すデフォルトの秒数 (レスポンスの TTL の精度が秒なので、このオプションの精度も秒です) (デフォルト: <tt class="docutils literal"><span class="pre">2</span></tt>)。
この設定値は HTTP <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> 拡張の <tt class="docutils literal"><span class="pre">stale-while-revalidate</span></tt> で上書きされます (RFC 5861 を参照)</li>
<li><tt class="docutils literal"><span class="pre">stale_if_error</span></tt>: エラーが発生してから、キャッシュが &#8220;stale&#8221; レスポンスを返す秒数を指定します (デフォルト: <tt class="docutils literal"><span class="pre">60</span></tt>)。
この設定値は HTTP <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> 拡張の <tt class="docutils literal"><span class="pre">stale-if-error</span></tt> で上書きされます (RFC 5861 を参照)</li>
</ul>
<p><tt class="docutils literal"><span class="pre">debug</span></tt> が <tt class="docutils literal"><span class="pre">true</span></tt> に設定されている場合、Symfony2 により自動的に <tt class="docutils literal"><span class="pre">X-Symfony-Cache</span></tt> ヘッダーがレスポンスに付加されるので、キャッシュのヒットやミスなどに関する調査に役立ちます。</p>
<div class="sidebar">
<p class="first sidebar-title">リバースプロキシを別の製品で置き換える</p>
<p>Symfony2 リバースプロキシは、Web サイトの開発中や、PHP コード以外をインストールできない共有サーバーへアプリケーションをデプロイしなければいけない場合などには、とても強力なツールです。
しかし、Symfony2 リバースプロキシは PHP で書かれていますので、C で書かれた他のプロキシほど高速ではありません。
ですので、もし可能であれば、運用環境では Varnish や Squid を使うことを推奨します。
このようにリバースプロキシを切り替えるのはとても簡単で、透過的です。
アプリケーションのコードを書き換える必要はありません。
最初は Symfony2 に組み込まれたリバースプロキシを利用し、トラフィックが増えた段階で Varnish にアップグレードするとよいでしょう。</p>
<p class="last">Symfony2 で Varnish を使う方法については、クックブックの <a class="reference internal" href="../cookbook/cache/varnish.html"><em>How to use Varnish</em></a> を参照してください。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Symfony2 リバースプロキシのパフォーマンスは、アプリケーションの複雑度には依存しません。
リクエストがアプリケーションへフォワードされた場合にのみ、アプリケーションカーネルが起動されるからです。</p>
</div>
</div>
</div>
<div class="section" id="http-cache-introduction">
<span id="index-4"></span><span id="id4"></span><h2>HTTP キャッシュの導入<a class="headerlink" href="#http-cache-introduction" title="Permalink to this headline">¶</a></h2>
<p>キャッシュレイヤーの機能を利用するには、どのレスポンスがキャッシュ可能か、および各キャッシュを有効期限切れとみなす時間や方法をアプリケーションからチェックできる必要があります。
通常、このようなチェックを行うには、レスポンスの HTTP キャッシュヘッダーを使います。</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">&#8220;HTTP&#8221; というのは、Web クライアントと Web サーバーがお互いに通信するのに使う、単なる言語 (単純なテキストの言語) 以上のものではないことに注意してください。
HTTP キャッシュについて話す場合、このテキスト言語の一部分で、クライアントとサーバーがキャッシュに関連する情報をやりとりできるようにすることについて話しています。</p>
</div>
<p>HTTP では、次の 4 つのレスポンスキャッシュヘッダーが定義されています:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Cache-Control</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Expires</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ETag</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Last-Modified</span></tt></li>
</ul>
<p>もっとも重要で広く利用されるヘッダーは、<tt class="docutils literal"><span class="pre">Cache-Control</span></tt> ヘッダーです。
このヘッダーには、キャッシュに関するさまざまな情報が含まれています。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Each of the headers will be explained in full detail in the
<a class="reference internal" href="#http-expiration-validation"><em>HTTP キャッシュの有効期限と期限切れの検証</em></a> section.</p>
</div>
<div class="section" id="cache-control">
<span id="index-5"></span><h3>Cache-Control ヘッダー<a class="headerlink" href="#cache-control" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> header is unique in that it contains not one, but various
pieces of information about the cacheability of a response. Each piece of
information is separated by a comma:</p>
<blockquote>
<div><p>Cache-Control: private, max-age=0, must-revalidate</p>
<p>Cache-Control: max-age=3600, must-revalidate</p>
</div></blockquote>
<p>Symfony provides an abstraction around the <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> header to make
its creation more manageable:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">();</span>

<span class="c1">// mark the response as either public or private</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setPublic</span><span class="p">();</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setPrivate</span><span class="p">();</span>

<span class="c1">// set the private or shared max age</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setMaxAge</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setSharedMaxAge</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>

<span class="c1">// set a custom Cache-Control directive</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">addCacheControlDirective</span><span class="p">(</span><span class="s1">&#39;must-revalidate&#39;</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="public-private">
<h3>レスポンスの Public と Private<a class="headerlink" href="#public-private" title="Permalink to this headline">¶</a></h3>
<p>Both gateway and proxy caches are considered &#8220;shared&#8221; caches as the cached
content is shared by more than one user. If a user-specific response were
ever mistakenly stored by a shared cache, it might be returned later to any
number of different users. Imagine if your account information were cached
and then returned to every subsequent user who asked for their account page!</p>
<p>To handle this situation, every response may be set to be public or private:</p>
<ul class="simple">
<li><em>public</em>: Indicates that the response may be cached by both private and
shared caches;</li>
<li><em>private</em>: Indicates that all or part of the response message is intended
for a single user and must not be cached by a shared cache.</li>
</ul>
<p>Symfony conservatively defaults each response to be private. To take advantage
of shared caches (like the Symfony2 reverse proxy), the response will need
to be explicitly set as public.</p>
</div>
<div class="section" id="index-6">
<span id="id5"></span><h3>安全なメソッド<a class="headerlink" href="#index-6" title="Permalink to this headline">¶</a></h3>
<p>HTTP caching only works for &#8220;safe&#8221; HTTP methods (like GET and HEAD). Being
safe means that you never change the application&#8217;s state on the server when
serving the request (you can of course log information, cache data, etc).
This has two very reasonable consequences:</p>
<ul class="simple">
<li>You should <em>never</em> change the state of your application when responding
to a GET or HEAD request. Even if you don&#8217;t use a gateway cache, the presence
of proxy caches mean that any GET or HEAD request may or may not actually
hit your server.</li>
<li>Don&#8217;t expect PUT, POST or DELETE methods to cache. These methods are meant
to be used when mutating the state of your application (e.g. deleting a
blog post). Caching them would prevent certain requests from hitting and
mutating your application.</li>
</ul>
</div>
<div class="section" id="id6">
<h3>キャッシュのルールとデフォルト<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>HTTP 1.1 allows caching anything by default unless there is an explicit
<tt class="docutils literal"><span class="pre">Cache-Control</span></tt> header. In practice, most caches do nothing when requests
have a cookie, an authorization header, use a non-safe method (i.e. PUT, POST,
DELETE), or when responses have a redirect status code.</p>
<p>Symfony2 automatically sets a sensible and conservative <tt class="docutils literal"><span class="pre">Cache-Control</span></tt>
header when none is set by the developer by following these rules:</p>
<ul class="simple">
<li>If no cache header is defined (<tt class="docutils literal"><span class="pre">Cache-Control</span></tt>, <tt class="docutils literal"><span class="pre">Expires</span></tt>, <tt class="docutils literal"><span class="pre">ETag</span></tt>
or <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>), <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> is set to <tt class="docutils literal"><span class="pre">no-cache</span></tt>, meaning
that the response will not be cached;</li>
<li>If <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> is empty (but one of the other cache headers is present),
its value is set to <tt class="docutils literal"><span class="pre">private,</span> <span class="pre">must-revalidate</span></tt>;</li>
<li>But if at least one <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> directive is set, and no &#8216;public&#8217; or
<tt class="docutils literal"><span class="pre">private</span></tt> directives have been explicitly added, Symfony2 adds the
<tt class="docutils literal"><span class="pre">private</span></tt> directive automatically (except when <tt class="docutils literal"><span class="pre">s-maxage</span></tt> is set).</li>
</ul>
</div>
</div>
<div class="section" id="http-expiration-validation">
<span id="id7"></span><h2>HTTP キャッシュの有効期限と期限切れの検証<a class="headerlink" href="#http-expiration-validation" title="Permalink to this headline">¶</a></h2>
<p>The HTTP specification defines two caching models:</p>
<ul class="simple">
<li>With the <a class="reference external" href="http://tools.ietf.org/html/rfc2616#section-13.2">expiration model</a>, you simply specify how long a response should
be considered &#8220;fresh&#8221; by including a <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> and/or an <tt class="docutils literal"><span class="pre">Expires</span></tt>
header. Caches that understand expiration will not make the same request
until the cached version reaches its expiration time and becomes &#8220;stale&#8221;.</li>
<li>When pages are really dynamic (i.e. their representation changes often),
the <a class="reference external" href="http://tools.ietf.org/html/rfc2616#section-13.3">validation model</a> model is often necessary. With this model, the
cache stores the response, but asks the server on each request whether
or not the cached response is still valid. The application uses a unique
response identifier (the <tt class="docutils literal"><span class="pre">Etag</span></tt> header) and/or a timestamp (the <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>
header) to check if the page has changed since being cached.</li>
</ul>
<p>The goal of both models is to never generate the same response twice by relying
on a cache to store and return &#8220;fresh&#8221; responses.</p>
<div class="sidebar">
<p class="first sidebar-title">Reading the HTTP Specification</p>
<p>The HTTP specification defines a simple but powerful language in which
clients and servers can communicate. As a web developer, the request-response
model of the specification dominates our work. Unfortunately, the actual
specification document - <a class="reference external" href="http://tools.ietf.org/html/rfc2616">RFC 2616</a> - can be difficult to read.</p>
<p>There is an on-going effort (<a class="reference external" href="http://tools.ietf.org/wg/httpbis/">HTTP Bis</a>) to rewrite the RFC 2616. It does
not describe a new version of HTTP, but mostly clarifies the original HTTP
specification. The organization is also improved as the specification
is split into seven parts; everything related to HTTP caching can be
found in two dedicated parts (<a class="reference external" href="http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-12">P4 - Conditional Requests</a> and <a class="reference external" href="http://tools.ietf.org/html/draft-ietf-httpbis-p6-cache-12">P6 -
Caching: Browser and intermediary caches</a>).</p>
<p class="last">As a web developer, we strongly urge you to read the specification. Its
clarity and power - even more than ten years after its creation - is
invaluable. Don&#8217;t be put-off by the appearance of the spec - its contents
are much more beautiful than its cover.</p>
</div>
<div class="section" id="index-7">
<span id="id8"></span><h3>有効期限<a class="headerlink" href="#index-7" title="Permalink to this headline">¶</a></h3>
<p>The expiration model is the more efficient and straightforward of the two
caching models and should be used whenever possible. When a response is cached
with an expiration, the cache will store the response and return it directly
without hitting the application until it expires.</p>
<p>The expiration model can be accomplished using one of two, nearly identical,
HTTP headers: <tt class="docutils literal"><span class="pre">Expires</span></tt> or <tt class="docutils literal"><span class="pre">Cache-Control</span></tt>.</p>
</div>
<div class="section" id="expires">
<span id="index-8"></span><h3><tt class="docutils literal"><span class="pre">Expires</span></tt> ヘッダーを使った有効期限の設定<a class="headerlink" href="#expires" title="Permalink to this headline">¶</a></h3>
<p>According to the HTTP specification, &#8220;the <tt class="docutils literal"><span class="pre">Expires</span></tt> header field gives
the date/time after which the response is considered stale.&#8221; The <tt class="docutils literal"><span class="pre">Expires</span></tt>
header can be set with the <tt class="docutils literal"><span class="pre">setExpires()</span></tt> <tt class="docutils literal"><span class="pre">Response</span></tt> method. It takes a
<tt class="docutils literal"><span class="pre">DateTime</span></tt> instance as an argument:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$date</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DateTime</span><span class="p">();</span>
<span class="nv">$date</span><span class="o">-&gt;</span><span class="na">modify</span><span class="p">(</span><span class="s1">&#39;+600 seconds&#39;</span><span class="p">);</span>

<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setExpires</span><span class="p">(</span><span class="nv">$date</span><span class="p">);</span>
</pre></div>
</div>
<p>The resulting HTTP header will look like this:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nx">Expires</span><span class="o">:</span> <span class="nx">Thu</span><span class="p">,</span> <span class="mo">01</span> <span class="nx">Mar</span> <span class="mi">2011</span> <span class="mi">16</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mo">00</span> <span class="nx">GMT</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal"><span class="pre">setExpires()</span></tt> method automatically converts the date to the GMT
timezone as required by the specification.</p>
</div>
<p>The <tt class="docutils literal"><span class="pre">Expires</span></tt> header suffers from two limitations. First, the clocks on the
Web server and the cache (e.g. the browser) must be synchronized. Then, the
specification states that &#8220;HTTP/1.1 servers should not send <tt class="docutils literal"><span class="pre">Expires</span></tt> dates
more than one year in the future.&#8221;</p>
</div>
<div class="section" id="index-9">
<span id="id9"></span><h3><tt class="docutils literal"><span class="pre">Cache-Control</span></tt> ヘッダーを使った有効期限の設定<a class="headerlink" href="#index-9" title="Permalink to this headline">¶</a></h3>
<p>Because of the <tt class="docutils literal"><span class="pre">Expires</span></tt> header limitations, most of the time, you should
use the <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> header instead. Recall that the <tt class="docutils literal"><span class="pre">Cache-Control</span></tt>
header is used to specify many different cache directives. For expiration,
there are two directives, <tt class="docutils literal"><span class="pre">max-age</span></tt> and <tt class="docutils literal"><span class="pre">s-maxage</span></tt>. The first one is
used by all caches, whereas the second one is only taken into account by
shared caches:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// Sets the number of seconds after which the response</span>
<span class="c1">// should no longer be considered fresh</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setMaxAge</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>

<span class="c1">// Same as above but only for shared caches</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setSharedMaxAge</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> header would take on the following format (it may have
additional directives):</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nx">Cache</span><span class="o">-</span><span class="nx">Control</span><span class="o">:</span> <span class="nx">max</span><span class="o">-</span><span class="nx">age</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="nx">s</span><span class="o">-</span><span class="nx">maxage</span><span class="o">=</span><span class="mi">600</span>
</pre></div>
</div>
</div>
<div class="section" id="index-10">
<span id="id10"></span><h3>期限切れの検証<a class="headerlink" href="#index-10" title="Permalink to this headline">¶</a></h3>
<p>When a resource needs to be updated as soon as a change is made to the underlying
data, the expiration model falls short. With the expiration model, the application
won&#8217;t be asked to return the updated response until the cache finally becomes
stale.</p>
<p>The validation model addresses this issue. Under this model, the cache continues
to store responses. The difference is that, for each request, the cache asks
the application whether or not the cached response is still valid. If the
cache <em>is</em> still valid, your application should return a 304 status code
and no content. This tells the cache that it&#8217;s ok to return the cached response.</p>
<p>Under this model, you mainly save bandwidth as the representation is not
sent twice to the same client (a 304 response is sent instead). But if you
design your application carefully, you might be able to get the bare minimum
data needed to send a 304 response and save CPU also (see below for an implementation
example).</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">The 304 status code means &#8220;Not Modified&#8221;. It&#8217;s important because with
this status code do <em>not</em> contain the actual content being requested.
Instead, the response is simply a light-weight set of directions that
tell cache that it should use its stored version.</p>
</div>
<p>Like with expiration, there are two different HTTP headers that can be used
to implement the validation model: <tt class="docutils literal"><span class="pre">ETag</span></tt> and <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>.</p>
</div>
<div class="section" id="etag">
<span id="index-11"></span><h3><tt class="docutils literal"><span class="pre">ETag</span></tt> ヘッダーを使った検証<a class="headerlink" href="#etag" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">ETag</span></tt> header is a string header (called the &#8220;entity-tag&#8221;) that uniquely
identifies one representation of the target resource. It&#8217;s entirely generated
and set by your application so that you can tell, for example, if the <tt class="docutils literal"><span class="pre">/about</span></tt>
resource that&#8217;s stored by the cache is up-to-date with what your application
would return. An <tt class="docutils literal"><span class="pre">ETag</span></tt> is like a fingerprint and is used to quickly compare
if two different versions of a resource are equivalent. Like fingerprints,
each <tt class="docutils literal"><span class="pre">ETag</span></tt> must be unique across all representations of the same resource.</p>
<p>Let&#8217;s walk through a simple implementation that generates the ETag as the
md5 of the content:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">indexAction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">render</span><span class="p">(</span><span class="s1">&#39;MyBundle:Main:index.html.twig&#39;</span><span class="p">);</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setETag</span><span class="p">(</span><span class="nb">md5</span><span class="p">(</span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getContent</span><span class="p">()));</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">isNotModified</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getRequest</span><span class="p">());</span>

    <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">Response::isNotModified()</span></tt> method compares the <tt class="docutils literal"><span class="pre">ETag</span></tt> sent with
the <tt class="docutils literal"><span class="pre">Request</span></tt> with the one set on the <tt class="docutils literal"><span class="pre">Response</span></tt>. If the two match, the
method automatically sets the <tt class="docutils literal"><span class="pre">Response</span></tt> status code to 304.</p>
<p>This algorithm is simple enough and very generic, but you need to create the
whole <tt class="docutils literal"><span class="pre">Response</span></tt> before being able to compute the ETag, which is sub-optimal.
In other words, it saves on bandwidth, but not CPU cycles.</p>
<p>In the <a class="reference internal" href="#optimizing-cache-validation"><em>有効期限の検証を使ってコードを最適化する</em></a> section, we&#8217;ll show how validation
can be used more intelligently to determine the validity of a cache without
doing so much work.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Symfony2 also supports weak ETags by passing <tt class="docutils literal"><span class="pre">true</span></tt> as the second
argument to the
<a href="#id11"><span class="problematic" id="id12">:method:`Symfony\\Component\\HttpFoundation\\Response::setETag`</span></a> method.</p>
</div>
</div>
<div class="section" id="last-modified">
<span id="index-12"></span><h3><tt class="docutils literal"><span class="pre">Last-Modified</span></tt> ヘッダーを使った検証<a class="headerlink" href="#last-modified" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> header is the second form of validation. According
to the HTTP specification, &#8220;The <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> header field indicates
the date and time at which the origin server believes the representation
was last modified.&#8221; In other words, the application decides whether or not
the cached content has been updated based on whether or not it&#8217;s been updated
since the response was cached.</p>
<p>For instance, you can use the latest update date for all the objects needed to
compute the resource representation as the value for the <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>
header value:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">showAction</span><span class="p">(</span><span class="nv">$articleSlug</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="nv">$articleDate</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\DateTime</span><span class="p">(</span><span class="nv">$article</span><span class="o">-&gt;</span><span class="na">getUpdatedAt</span><span class="p">());</span>
    <span class="nv">$authorDate</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\DateTime</span><span class="p">(</span><span class="nv">$author</span><span class="o">-&gt;</span><span class="na">getUpdatedAt</span><span class="p">());</span>

    <span class="nv">$date</span> <span class="o">=</span> <span class="nv">$authorDate</span> <span class="o">&gt;</span> <span class="nv">$articleDate</span> <span class="o">?</span> <span class="nv">$authorDate</span> <span class="o">:</span> <span class="nv">$articleDate</span><span class="p">;</span>

    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setLastModified</span><span class="p">(</span><span class="nv">$date</span><span class="p">);</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">isNotModified</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getRequest</span><span class="p">());</span>

    <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">Response::isNotModified()</span></tt> method compares the <tt class="docutils literal"><span class="pre">If-Modified-Since</span></tt>
header sent by the request with the <tt class="docutils literal"><span class="pre">Last-Modified</span></tt> header set on the
response. If they are equivalent, the <tt class="docutils literal"><span class="pre">Response</span></tt> will be set to a 304 status
code.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal"><span class="pre">If-Modified-Since</span></tt> request header equals the <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>
header of the last response sent to the client for the particular resource.
This is how the client and server communicate with each other and decide
whether or not the resource has been updated since it was cached.</p>
</div>
</div>
<div class="section" id="optimizing-cache-validation">
<span id="index-13"></span><span id="id13"></span><h3>有効期限の検証を使ってコードを最適化する<a class="headerlink" href="#optimizing-cache-validation" title="Permalink to this headline">¶</a></h3>
<p>The main goal of any caching strategy is to lighten the load on the application.
Put another way, the less you do in your application to return a 304 response,
the better. The <tt class="docutils literal"><span class="pre">Response::isNotModified()</span></tt> method does exactly that by
exposing a simple and efficient pattern:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">showAction</span><span class="p">(</span><span class="nv">$articleSlug</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get the minimum information to compute</span>
    <span class="c1">// the ETag or the Last-Modified value</span>
    <span class="c1">// (based on the Request, data are retrieved from</span>
    <span class="c1">// a database or a key-value store for instance)</span>
    <span class="nv">$article</span> <span class="o">=</span> <span class="c1">// ...</span>

    <span class="c1">// create a Response with a ETag and/or a Last-Modified header</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">();</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setETag</span><span class="p">(</span><span class="nv">$article</span><span class="o">-&gt;</span><span class="na">computeETag</span><span class="p">());</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setLastModified</span><span class="p">(</span><span class="nv">$article</span><span class="o">-&gt;</span><span class="na">getPublishedAt</span><span class="p">());</span>

    <span class="c1">// Check that the Response is not modified for the given Request</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">isNotModified</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getRequest</span><span class="p">()))</span> <span class="p">{</span>
        <span class="c1">// return the 304 Response immediately</span>
        <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// do more work here - like retrieving more data</span>
        <span class="nv">$comments</span> <span class="o">=</span> <span class="c1">// ...</span>

        <span class="c1">// or render a template with the $response you&#39;ve already started</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">render</span><span class="p">(</span>
            <span class="s1">&#39;MyBundle:MyController:article.html.twig&#39;</span><span class="p">,</span>
            <span class="k">array</span><span class="p">(</span><span class="s1">&#39;article&#39;</span> <span class="o">=&gt;</span> <span class="nv">$article</span><span class="p">,</span> <span class="s1">&#39;comments&#39;</span> <span class="o">=&gt;</span> <span class="nv">$comments</span><span class="p">),</span>
            <span class="nv">$response</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When the <tt class="docutils literal"><span class="pre">Response</span></tt> is not modified, the <tt class="docutils literal"><span class="pre">isNotModified()</span></tt> automatically sets
the response status code to <tt class="docutils literal"><span class="pre">304</span></tt>, removes the content, and removes some
headers that must not be present for <tt class="docutils literal"><span class="pre">304</span></tt> responses (see
<a href="#id14"><span class="problematic" id="id15">:method:`Symfony\\Component\\HttpFoundation\\Response::setNotModified`</span></a>).</p>
</div>
<div class="section" id="varying-the-response">
<span id="index-14"></span><h3>Varying the Response<a class="headerlink" href="#varying-the-response" title="Permalink to this headline">¶</a></h3>
<p>So far, we&#8217;ve assumed that each URI has exactly one representation of the
target resource. By default, HTTP caching is done by using the URI of the
resource as the cache key. If two people request the same URI of a cacheable
resource, the second person will receive the cached version.</p>
<p>Sometimes this isn&#8217;t enough and different versions of the same URI need to
be cached based on one or more request header values. For instance, if you
compress pages when the client supports it, any given URI has two representations:
one when the client supports compression, and one when it does not. This
determination is done by the value of the <tt class="docutils literal"><span class="pre">Accept-Encoding</span></tt> request header.</p>
<p>In this case, we need the cache to store both a compressed and uncompressed
version of the response for the particular URI and return them based on the
request&#8217;s <tt class="docutils literal"><span class="pre">Accept-Encoding</span></tt> value. This is done by using the <tt class="docutils literal"><span class="pre">Vary</span></tt> response
header, which is a comma-separated list of different headers whose values
trigger a different representation of the requested resource:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nx">Vary</span><span class="o">:</span> <span class="nx">Accept</span><span class="o">-</span><span class="nx">Encoding</span><span class="p">,</span> <span class="nx">User</span><span class="o">-</span><span class="nx">Agent</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">This particular <tt class="docutils literal"><span class="pre">Vary</span></tt> header would cache different versions of each
resource based on the URI and the value of the <tt class="docutils literal"><span class="pre">Accept-Encoding</span></tt> and
<tt class="docutils literal"><span class="pre">User-Agent</span></tt> request header.</p>
</div>
<p>The <tt class="docutils literal"><span class="pre">Response</span></tt> object offers a clean interface for managing the <tt class="docutils literal"><span class="pre">Vary</span></tt>
header:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// set one vary header</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setVary</span><span class="p">(</span><span class="s1">&#39;Accept-Encoding&#39;</span><span class="p">);</span>

<span class="c1">// set multiple vary headers</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setVary</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;Accept-Encoding&#39;</span><span class="p">,</span> <span class="s1">&#39;User-Agent&#39;</span><span class="p">));</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">setVary()</span></tt> method takes a header name or an array of header names for
which the response varies.</p>
</div>
<div class="section" id="id16">
<h3>有効期限と期限の検証<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>You can of course use both validation and expiration within the same <tt class="docutils literal"><span class="pre">Response</span></tt>.
As expiration wins over validation, you can easily benefit from the best of
both worlds. In other words, by using both expiration and validation, you
can instruct the cache to server the cached content, while checking back
at some interval (the expiration) to verify that the content is still valid.</p>
</div>
<div class="section" id="response">
<span id="index-15"></span><h3>Response の他のメソッド<a class="headerlink" href="#response" title="Permalink to this headline">¶</a></h3>
<p>The Response class provides many more methods related to the cache. Here are
the most useful ones:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// Marks the Response stale</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">expire</span><span class="p">();</span>

<span class="c1">// Force the response to return a proper 304 response with no content</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setNotModified</span><span class="p">();</span>
</pre></div>
</div>
<p>Additionally, most cache-related HTTP headers can be set via the single
<tt class="docutils literal"><span class="pre">setCache()</span></tt> method:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// Set cache settings in one call</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setCache</span><span class="p">(</span><span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;etag&#39;</span>          <span class="o">=&gt;</span> <span class="nv">$etag</span><span class="p">,</span>
    <span class="s1">&#39;last_modified&#39;</span> <span class="o">=&gt;</span> <span class="nv">$date</span><span class="p">,</span>
    <span class="s1">&#39;max_age&#39;</span>       <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;s_maxage&#39;</span>      <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">,</span>
    <span class="s1">&#39;public&#39;</span>        <span class="o">=&gt;</span> <span class="k">true</span><span class="p">,</span>
    <span class="c1">// &#39;private&#39;    =&gt; true,</span>
<span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="edge-side-includes">
<span id="index-16"></span><span id="id17"></span><h2>Edge Side Includes の使い方<a class="headerlink" href="#edge-side-includes" title="Permalink to this headline">¶</a></h2>
<p>Gateway caches are a great way to make your website perform better. But they
have one limitation: they can only cache whole pages. If you can&#8217;t cache
whole pages or if parts of a page has &#8220;more&#8221; dynamic parts, you are out of
luck. Fortunately, Symfony2 provides a solution for these cases, based on a
technology called <a class="reference external" href="http://www.w3.org/TR/esi-lang">ESI</a>, or Edge Side Includes. Akama誰 wrote this specification
almost 10 years ago, and it allows specific parts of a page to have a different
caching strategy than the main page.</p>
<p>The ESI specification describes tags you can embed in your pages to communicate
with the gateway cache. Only one tag is implemented in Symfony2, <tt class="docutils literal"><span class="pre">include</span></tt>,
as this is the only useful one outside of Akama誰 context:</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;html&gt;</span>
    <span class="nt">&lt;body&gt;</span>
        Some content

        <span class="c">&lt;!-- Embed the content of another page here --&gt;</span>
        <span class="nt">&lt;esi:include</span> <span class="na">src=</span><span class="s">&quot;http://...&quot;</span> <span class="nt">/&gt;</span>

        More content
    <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Notice from the example that each ESI tag has a fully-qualified URL.
An ESI tag represents a page fragment that can be fetched via the given
URL.</p>
</div>
<p>When a request is handled, the gateway cache fetches the entire page from
its cache or requests it from the backend application. If the response contains
one or more ESI tags, these are processed in the same way. In other words,
the gateway cache either retrieves the included page fragment from its cache
or requests the page fragment from the backend application again. When all
the ESI tags have been resolved, the gateway cache merges each into the main
page and sends the final content to the client.</p>
<p>All of this happens transparently at the gateway cache level (i.e. outside
of your application). As you&#8217;ll see, if you choose to take advantage of ESI
tags, Symfony2 makes the process of including them almost effortless.</p>
<div class="section" id="using-esi-in-symfony2">
<h3>Using ESI in Symfony2<a class="headerlink" href="#using-esi-in-symfony2" title="Permalink to this headline">¶</a></h3>
<p>First, to use ESI, be sure to enable it in your application configuration:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/config.yml</span>
<span class="l-Scalar-Plain">framework</span><span class="p-Indicator">:</span>
    <span class="c1"># ...</span>
    <span class="l-Scalar-Plain">esi</span><span class="p-Indicator">:</span> <span class="p-Indicator">{</span> <span class="nv">enabled</span><span class="p-Indicator">:</span> <span class="nv">true</span> <span class="p-Indicator">}</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><pre>&lt;!-- app/config/config.xml --&gt;
&lt;framework:config ...&gt;
    &lt;!-- ... --&gt;
    &lt;framework:esi enabled="true" /&gt;
&lt;/framework:config&gt;</pre>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="c1">// app/config/config.php</span>
<span class="nv">$container</span><span class="o">-&gt;</span><span class="na">loadFromExtension</span><span class="p">(</span><span class="s1">&#39;framework&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="c1">// ...</span>
    <span class="s1">&#39;esi&#39;</span>    <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;enabled&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">),</span>
<span class="p">));</span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>Now, suppose we have a page that is relatively static, except for a news
ticker at the bottom of the content. With ESI, we can cache the news ticker
independent of the rest of the page.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">indexAction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">render</span><span class="p">(</span><span class="s1">&#39;MyBundle:MyController:index.html.twig&#39;</span><span class="p">);</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setSharedMaxAge</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>

    <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, we&#8217;ve given the full-page cache a lifetime of ten minutes.
Next, let&#8217;s include the news ticker in the template by embedding an action.
This is done via the <tt class="docutils literal"><span class="pre">render</span></tt> helper (See <cite>templating-embedding-controller</cite>
for more details).</p>
<p>As the embedded content comes from another page (or controller for that
matter), Symfony2 uses the standard <tt class="docutils literal"><span class="pre">render</span></tt> helper to configure ESI tags:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>Twig</em><div class="highlight-jinja"><div class="highlight"><pre><span class="cp">{%</span> <span class="k">render</span> <span class="s1">&#39;...:news&#39;</span> <span class="k">with</span> <span class="o">{},</span> <span class="o">{</span><span class="s1">&#39;standalone&#39;</span><span class="o">:</span> <span class="kp">true</span><span class="o">}</span> <span class="cp">%}</span><span class="x"></span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="o">&lt;?</span><span class="nx">php</span> <span class="k">echo</span> <span class="nv">$view</span><span class="p">[</span><span class="s1">&#39;actions&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">render</span><span class="p">(</span><span class="s1">&#39;...:news&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(),</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;standalone&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">))</span> <span class="cp">?&gt;</span><span class="x"></span>
</pre></div>
</div>
</li>
</ul>
</div>
<p>By setting <tt class="docutils literal"><span class="pre">standalone</span></tt> to <tt class="docutils literal"><span class="pre">true</span></tt>, you tell Symfony2 that the action
should be rendered as an ESI tag. You might be wondering why you would want to
use a helper instead of just writing the ESI tag yourself. That&#8217;s because
using a helper makes your application work even if there is no gateway cache
installed. Let&#8217;s see how it works.</p>
<p>When standalone is <tt class="docutils literal"><span class="pre">false</span></tt> (the default), Symfony2 merges the included page
content within the main one before sending the response to the client. But
when standalone is <tt class="docutils literal"><span class="pre">true</span></tt>, <em>and</em> if Symfony2 detects that it&#8217;s talking
to a gateway cache that supports ESI, it generates an ESI include tag. But
if there is no gateway cache or if it does not support ESI, Symfony2 will
just merge the included page content within the main one as it would have
done were standalone set to <tt class="docutils literal"><span class="pre">false</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Symfony2 detects if a gateway cache supports ESI via another Akama誰
specification that is supported out of the box by the Symfony2 reverse
proxy.</p>
</div>
<p>The embedded action can now specify its own caching rules, entirely independent
of the master page.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">public</span> <span class="k">function</span> <span class="nf">newsAction</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// ...</span>

  <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setSharedMaxAge</span><span class="p">(</span><span class="mi">60</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With ESI, the full page cache will be valid for 600 seconds, but the news
component cache will only last for 60 seconds.</p>
<p>A requirement of ESI, however, is that the embedded action be accessible
via a URL so the gateway cache can fetch it independently of the rest of
the page. Of course, an action can&#8217;t be accessed via a URL unless it has
a route that points to it. Symfony2 takes care of this via a generic route
and controller. For the ESI include tag to work properly, you must define
the <tt class="docutils literal"><span class="pre">_internal</span></tt> route:</p>
<div class="configuration-block">
<ul class="simple">
<li><em>YAML</em><div class="highlight-yaml"><div class="highlight"><pre><span class="c1"># app/config/routing.yml</span>
<span class="l-Scalar-Plain">_internal</span><span class="p-Indicator">:</span>
    <span class="l-Scalar-Plain">resource</span><span class="p-Indicator">:</span> <span class="s">&quot;@FrameworkBundle/Resources/config/routing/internal.xml&quot;</span>
    <span class="l-Scalar-Plain">prefix</span><span class="p-Indicator">:</span>   <span class="l-Scalar-Plain">/_internal</span>
</pre></div>
</div>
</li>
<li><em>XML</em><div class="highlight-xml"><div class="highlight"><pre><span class="c">&lt;!-- app/config/routing.xml --&gt;</span>
<span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>

<span class="nt">&lt;routes</span> <span class="na">xmlns=</span><span class="s">&quot;http://symfony.com/schema/routing&quot;</span>
    <span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd&quot;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">&quot;@FrameworkBundle/Resources/config/routing/internal.xml&quot;</span> <span class="na">prefix=</span><span class="s">&quot;/_internal&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/routes&gt;</span>
</pre></div>
</div>
</li>
<li><em>PHP</em><div class="highlight-php"><div class="highlight"><pre><span class="c1">// app/config/routing.php</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Routing\RouteCollection</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Routing\Route</span><span class="p">;</span>

<span class="nv">$collection</span><span class="o">-&gt;</span><span class="na">addCollection</span><span class="p">(</span><span class="nv">$loader</span><span class="o">-&gt;</span><span class="na">import</span><span class="p">(</span><span class="s1">&#39;@FrameworkBundle/Resources/config/routing/internal.xml&#39;</span><span class="p">,</span> <span class="s1">&#39;/_internal&#39;</span><span class="p">));</span>

<span class="k">return</span> <span class="nv">$collection</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Since this route allows all actions to be accessed via a URL, you might
want to protect it by using the Symfony2 firewall feature (by allowing
access to your reverse proxy&#8217;s IP range).</p>
</div>
<p>One great advantage of this caching strategy is that you can make your
application as dynamic as needed and at the same time, hit the application as
little as possible.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Once you start using ESI, remember to always use the <tt class="docutils literal"><span class="pre">s-maxage</span></tt>
directive instead of <tt class="docutils literal"><span class="pre">max-age</span></tt>. As the browser only ever receives the
aggregated resource, it is not aware of the sub-components, and so it will
obey the <tt class="docutils literal"><span class="pre">max-age</span></tt> directive and cache the entire page. And you don&#8217;t
want that.</p>
</div>
<p>The <tt class="docutils literal"><span class="pre">render</span></tt> helper supports two other useful options:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">alt</span></tt>: used as the <tt class="docutils literal"><span class="pre">alt</span></tt> attribute on the ESI tag, which allows you
to specify an alternative URL to be used if the <tt class="docutils literal"><span class="pre">src</span></tt> cannot be found;</li>
<li><tt class="docutils literal"><span class="pre">ignore_errors</span></tt>: if set to true, an <tt class="docutils literal"><span class="pre">onerror</span></tt> attribute will be added
to the ESI with a value of <tt class="docutils literal"><span class="pre">continue</span></tt> indicating that, in the event of
a failure, the gateway cache will simply remove the ESI tag silently.</li>
</ul>
</div>
</div>
<div class="section" id="cache-invalidation">
<span id="http-cache-invalidation"></span><span id="index-17"></span><h2>Cache Invalidation<a class="headerlink" href="#cache-invalidation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>&#8220;There are only two hard things in Computer Science: cache invalidation
and naming things.&#8221; &#8211;Phil Karlton</div></blockquote>
<p>You should never need to invalidate cached data because invalidation is already
taken into account natively in the HTTP cache models. If you use validation,
you never need to invalidate anything by definition; and if you use expiration
and need to invalidate a resource, it means that you set the expires date
too far away in the future.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It&#8217;s also because there is no invalidation mechanism that you can use any
reverse proxy without changing anything in your application code.</p>
</div>
<p>Actually, all reverse proxies provide ways to purge cached data, but you
should avoid them as much as possible. The most standard way is to purge the
cache for a given URL by requesting it with the special <tt class="docutils literal"><span class="pre">PURGE</span></tt> HTTP method.</p>
<p>Here is how you can configure the Symfony2 reverse proxy to support the
<tt class="docutils literal"><span class="pre">PURGE</span></tt> HTTP method:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// app/AppCache.php</span>
<span class="k">class</span> <span class="nc">AppCache</span> <span class="k">extends</span> <span class="nx">Cache</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">invalidate</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;PURGE&#39;</span> <span class="o">!==</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getMethod</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">parent</span><span class="o">::</span><span class="na">invalidate</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">store</span><span class="o">-&gt;</span><span class="na">purge</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getUri</span><span class="p">()))</span> <span class="p">{</span>
            <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setStatusCode</span><span class="p">(</span><span class="mi">404</span><span class="p">,</span> <span class="s1">&#39;Not purged&#39;</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setStatusCode</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s1">&#39;Purged&#39;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">You must protect the <tt class="docutils literal"><span class="pre">PURGE</span></tt> HTTP method somehow to avoid random people
purging your cached data.</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>Symfony2 was designed to follow the proven rules of the road: HTTP. Caching
is no exception. Mastering the Symfony2 cache system means becoming familiar
with the HTTP cache models and using them effectively. This means that, instead
of relying only on Symfony2 documentation and code examples, you have access
to a world of knowledge related to HTTP caching and gateway caches such as
Varnish.</p>
</div>
<div class="section" id="learn-more-from-the-cookbook">
<h2>Learn more from the Cookbook<a class="headerlink" href="#learn-more-from-the-cookbook" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="../cookbook/cache/varnish.html"><em>Varnish を使ってウェブサイトを高速化する方法</em></a></li>
</ul>
</div>
</div>


<div id="page_prev_next">
<a class="prev" href="security.html">< セキュリティ</a>
<a class="next" href="translation.html">翻訳 ></a>
</div>

<div class="common_content_footer">
<ul>
  <li> → <a href="http://symfony.com/doc/master/book/http_cache.html">公式英語ドキュメント</a></li>
  <li> → <a href="https://github.com/symfony/symfony-docs/commits/master/book/http_cache.rst">原文コミット履歴</a>
  <li> → <a href="https://github.com/symfony-japan/symfony-docs-ja/commits/master/book/http_cache.rst">翻訳コミット履歴</a>
</ul>
<br />
翻訳の不備などは、お気軽にコメント欄にてご指摘ください。
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'symfony-japan'; // required: replace example with your forum shortname

    // The following are highly recommended additional parameters. Remove the slashes in front to use.
    // var disqus_identifier = 'unique_dynamic_id_1234';
    // var disqus_url = 'http://example.com/permalink-to-page.html';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

<div class="fb-like-box" data-href="http://www.facebook.com/symfonyjapan" data-width="203" data-show-faces="true" data-stream="true" data-border-color="#FFF" data-header="true"></div>

          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>

      </div>
      <!-- end #main -->
    </div>
    <!-- end #content_wrapper -->
  </div>
  <!-- end #content -->


  <div id="footer">
    <div id="footer_wrapper">
      <div id="footer_content">
        <div style=" position: relative;">
          <div id="footer_left"></div>
          <div id="footer_right"></div>
        </div>
        <div id="f_navbar">
        <ul>
          <li><a href="../index.html">トップ（索引）</a></li>
          <li><a href="../quick_tour/index.html">クイックツアー</a></li>
          <li><a href="index.html">ガイドブック</a></li>
          <li><a href="../cookbook/index.html">クックブック</a></li>
          <li><a href="../components/index.html">コンポーネント</a></li>
          <li><a href="../reference/index.html">リファレンス</a></li>
          <li><a href="../contributing/index.html">貢献</a></li>
        </ul>
      </div>
      <!-- end #navbar -->
        <div>
          <p id="copyright">
            <a href="../contributing/documentation/license.html">ドキュメントの著作権</a>は Symfony 公式に準じます(Creative Commons Attribution-Share Alike 3.0 Unported ライセンス)。<br />
            Copyright &copy; 2014 Symfony Japan. All rights reserved.<br />
            &nbsp;&nbsp;&nbsp;Bandwidth and hardware provided by <a href="http://www.asial.co.jp/">アシアル株式会社</a>
            &nbsp;&nbsp;Powered by <a href="http://sphinx.pocoo.org/">Sphinx</a>
          </p>
        </div>
      </div>
      <!-- end #footer_content -->
        </div>
        <!-- end #footer_wrapper -->
      </div>
      <!-- end #footer -->
    </div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-16659283-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
  </body>
</html>
